src\app\contexts\WorkflowContext.tsx:195:    const newOrdem: OrdemProducao = {
src\app\contexts\WorkflowContext.tsx:336:  const extrairMateriaisDaOrdem = (ordem: OrdemProducao): { materialId: string; quantidade: number; unidade: string; nome: string }[] => {
src\app\contexts\WorkflowContext.v2.tsx:25:  OrdemProducao,
src\app\pages\Ordens.tsx:21:import { OrdemProducao, StatusOrdem } from "../types/workflow";
src\app\pages\Ordens.tsx:37:  const [selectedOrdem, setSelectedOrdem] = useState<OrdemProducao | null>(null);
src\app\pages\Ordens.tsx:127:      render: (ord: OrdemProducao) => (
src\app\pages\Ordens.tsx:138:      render: (ord: OrdemProducao) => format(ord.dataAbertura, "dd/MM/yyyy", { locale: ptBR })
src\app\pages\Ordens.tsx:144:      render: (ord: OrdemProducao) => <span className="font-medium">{ord.clienteNome}</span>
src\app\pages\Ordens.tsx:149:      render: (ord: OrdemProducao) => (
src\app\pages\Ordens.tsx:156:      render: (ord: OrdemProducao) => (
src\app\pages\Ordens.tsx:165:      render: (ord: OrdemProducao) => (
src\app\pages\Ordens.tsx:174:      render: (ord: OrdemProducao) => (
src\app\pages\Ordens.tsx:184:  const handleIniciarProducao = async (ordem: OrdemProducao) => {
src\app\pages\Ordens.tsx:241:      onClick: (ord: OrdemProducao) => {
src\app\pages\Ordens.tsx:249:      show: (ord: OrdemProducao) => ord.status === "Pendente"
src\app\pages\Ordens.tsx:254:      onClick: (ord: OrdemProducao) => {
[2026-02-07T02:57:50] tokens used: 298.158

[2026-02-07T02:57:53] thinking

**Opening API handler file**
[2026-02-07T02:57:53] exec powershell.exe -Command "Get-Content 'src/services/http/producaoMockHandler.ts'" in C:\Users\Victoria\Documents\GitHub\INOX-VAL
[2026-02-07T02:57:54] powershell.exe -Command "Get-Content 'src/services/http/producaoMockHandler.ts'" succeeded in 639ms:
/**
 * Handler especÇÎÇøfico para rotas de produÇÎÇæÇÎ"o
 * Simula lÇÎÇ¬gica de backend para controle de produÇÎÇæÇÎ"o
 */

import { ordensMock, dashboardMock, materiaisMock } from '@/domains/producao';
import type { 
  OrdemProducaoCompleta, 
  OrdemProducaoItem,
  DashboardSetorData,
  ConsultaMaterial,
  SetorProducao,
  MovimentacaoSetor 
} from '@/domains/producao';
import { newId } from '@/shared/types/ids';

// Estado em memÇÎÇ¬ria (poderia usar IndexedDB tambÇÎ¶÷m)
let ordens: OrdemProducaoCompleta[] = [...ordensMock];
let dashboard: DashboardSetorData[] = [...dashboardMock];

[2026-02-07T02:57:54] tokens used: 348.689

[2026-02-07T02:58:17] thinking

**Drafting comprehensive implementation plan**
**Outlining detailed gap analysis and phased actions**

Iƒ?Tm organizing gaps like missing methods and type inconsistencies while planning phased stepsƒ?"from inventory through domain service build, mutations, querying, hooking, to tests and validationƒ?"ensuring alignment with Firestore rules, audit patterns, and front-end integration. Letƒ?Ts keep track of open questions about data storage and indexing to clarify later!

[2026-02-07T02:58:29] exec powershell.exe -Command "Get-Content 'src/domains/producao/pages/ApontamentoOP.tsx'" in C:\Users\Victoria\Documents\GitHub\INOX-VAL
[2026-02-07T02:58:31] powershell.exe -Command "Get-Content 'src/domains/producao/pages/ApontamentoOP.tsx'" succeeded in 1s:
/**
 * APONTAMENTO DE PRODUÇÎÇZÇÎ÷O - Interface para operadores no chÇÎ"o de fÇÎ¶ðbrica
 * - Login simplificado (seleÇÎÇæÇÎ"o de operador)
 * - Selecionar OP da fila
 * - Iniciar, Pausar, Retomar, Finalizar
 * - Interface touch-friendly (botÇÎÇÝes grandes)
 */

import { useState, useEffect } from 'react';
import { useOrdens } from '@/hooks/useOrdens';
import { Button } from '@/app/components/ui/button';
import { Card } from '@/app/components/ui/card';
import { Play, Pause, Square, Clock, User, AlertCircle } from 'lucide-react';
import type { OrdemProducao } from '@/app/types/workflow';

// Lista de operadores (em produÇÎÇæÇÎ"o viria do backend)
const OPERADORES = [
  { id: '1', nome: 'JoÇÎ"o Silva' },
  { id: '2', nome: 'Maria Santos' },
  { id: '3', nome: 'Pedro Costa' },
[2026-02-07T02:58:31] tokens used: 357.251

[2026-02-07T02:58:40] thinking

**Outlining detailed implementation plan**

I'm mapping out a comprehensive plan starting from the current state, covering existing files, identifying gaps, and defining clear action items. This plan includes referencing hooks like `useOrdens`, related service files, Firestore rules, and mock handlers, all tied together with checkpoints for testing and validation. I'll make sure to highlight incremental steps and open questions about data persistence and compatibility with the new base service pattern.
[2026-02-07T02:58:42] codex

Used the `plan` skill to document a structured execution plan for finishing the produÇõÇœo module from its current state.

# Plan

The produÇõÇœo domain currently exports only passive hooks/pages and a Firestore service re-export; the React Query hooks expect a richer API (listOrdens, setor mutations, dashboard, materials) that doesnƒ?Tt exist yet. The plan below inventories the existing assets, pinpoints the missing behaviors, and lays out an incremental, audit-friendly implementation path that reuses the new `FirestoreService` base (audit + soft delete pattern) while staying compatible with the hooks, UI, and Firestore rules/indexes already in place.

## Inventory
- `src/domains/producao/producao.hooks.ts`: React Query hooks for listing ordens, fetching items by setor, dashboard snapshots, material lookups, and mutations (`entradaSetor`, `saidaSetor`, `pausarItem`, etc.) that currently call undefined methods on `producaoService`.
- `src/domains/producao/producao.types.ts`: rich domain types (`OrdemProducaoCompleta`, `MovimentacaoSetor`, `ConsultaMaterial`, `SetorProducao`, etc.) that describe the payloads the UI expects.
- `src/domains/producao/pages/*`: `ControleProducao`, `DashboardTV`, `ApontamentoOP` UIs that rely on the hooks above plus the more generic `useOrdens` hook for TV/apontamento flows.
- `src/domains/producao/producao.seed.ts` + `src/services/http/producaoMockHandler.ts`: mock dataset and HTTP handler that document the desired REST behavior (listing ordens, setor entradas/saÇðdas, materiais, dashboard, status transitions).
- `src/services/firestore/base.ts`: the reusable `FirestoreService` implementing audit logs, soft delete, locked `empresaId`, and the generic `list/getById/create/update/remove` operations that must power the new domain behavior.
- `src/services/firestore/producao.service.ts`: Firestore service that extends the base with `ordens_producao` collection and `softDelete: true`.
- `src/services/firebase/producao.service.ts`: legacy Firebase-based service (no audit/soft delete) that should be retired once the domain service wraps the new Firestore implementation.
- `firestore.rules` and `firestore.indexes.json`: Firestore security rules and indexes already guard Reads/Writes on `ordens_producao` and support queries by `(empresaId,status,dataAbertura)`; no production-specific rules yet for sector mutations or movimentaÇõÇæes.

## Gaps & inconsistencies
- `producaoService` is just `export const producaoService = new FirestoreService(...)` so none of the domain-specific operations (`listOrdens`, `entradaSetor`, `getDashboardSetor`, etc.) exist despite being invoked in hooks/pages.
- The hooks reference detailed payloads (e.g., `MovimentacaoSetor` objects, material lookups, setor status updates) that have no Firestore implementation; the HTTP mock shows the expected semantics.
- `producao.types` describes nested item/material structures that must be kept in sync with Firestore documentsƒ?"currently there is no code ensuring Firestore keeps `itens` arrays, statuses, timestamps, or movimentaÇõÇæes consistent.
- Firestore rules only cover basic CRUD on `ordens_producao`; new mutations (setor entrada/saÇðda changes, progress updates, material consultations) may need additional indexes/guards, especially if filtering by `setorAtual`, `prioridade`, or writing to a `movimentacoes_setor` collection.
- Thereƒ?Ts no coordination between the multi-tenant/audit pattern in `FirestoreService` and the domain-specific flows, so even once methods exist they must wrap the base service to preserve audit logs, soft delete flags, and `empresaId` filtering.

## Requirements
- Support the hooksƒ?T query/mutation surface: `listOrdens(filters)`, `getOrdem(id)`, `getItensPorSetor(setor)`, `getDashboardSetor(setor?)`, `consultarMateriais(itemId)`, and the mutations `entradaSetor`, `saidaSetor`, `atualizarProgresso`, `rejeitarItem`, `pausarItem`, `retomarItem`.
- Align with the new Firestore pattern (audit logs, soft delete, automatic `empresaId`, `createdBy/updatedBy` metadata) by composing the domain service on top of `FirestoreService`.
- Respect existing Firestore rules/indexes for `ordens_producao`, and add any missing indexes/rules needed for sector filtering or new collections (e.g., movimentaÇõÇæes/consultas).
- Match UI expectations described in `ControleProducao`, `DashboardTV`, and `ApontamentoOP`, including sector sequences, material deficits, and dashboard stats.
- Avoid reintroducing legacy Firebase base services once the Firestore-backed domain service can cover the full surface.

## Scope
- In: domain hooks/pages, `producao.types`, `producao.seed`, `src/services/firestore/producao.service.ts`, Firestore rules/indexes relevant to production, and any new helper collections (movimentaÇõÇæes, dashboard snapshots).
- Out: the generic `useOrdens` hook and `ordens_producao` REST handlers (they already exist and can keep using the Firestore service once the domain service is complete).

## Files and entry points
- `src/domains/producao/producao.hooks.ts`
- `src/domains/producao/producao.service.ts`
- `src/domains/producao/producao.types.ts`
- `src/services/firestore/producao.service.ts`
- `src/services/firestore/base.ts`
- `src/services/http/producaoMockHandler.ts` (reference for required behavior)
- `firestore.rules` / `firestore.indexes.json`
- `src/domains/producao/pages/*` for UX expectations

## Data model / API changes
- Treat each `OrdemProducaoCompleta` document as the Firestore source of truth; updates will modify the nested `itens` array to reflect setor changes, progress, and status, while audit metadata is handled by the base service.
- Consider storing `MovimentacaoSetor` records either as a subcollection (`ordens_producao/{id}/movimentacoes`) or dedicated collection (need to decide) to track entradas/saÇðdas/rejeiÇõÇæes; include this decision in the plan.
- Dashboard data (`DashboardSetorData`) can be derived from live orders, but if Firestore-side aggregation is needed for performance, persist summaries in a supporting doc/collection and ensure indexes support `setor` filtering.
- Material consultations should either read the `materiaisNecessarios` stored on each item or compute them from related inventory documents; the mock stores them on the item, so the Firestore write/mutation flow must maintain those arrays.

## Action items
- [ ] Map every method stubbed in `producao.hooks.ts` to the corresponding Firestore operation by comparing to `src/services/http/producaoMockHandler.ts` (queries, payloads, sector sequences, material returns) so we have a precise contract for `producaoService`.
- [ ] Implement a domain wrapper (`ProducaoDomainService` or similar) that mirrors how `clientes.service.ts` wraps `clientesService`: expose `listOrdens(filters)`, `getOrdem(id)`, and other read APIs that call `producaoFirestoreService.list/getById` with the right `ListParams`, and normalize the results for the hooks.
- [ ] Add sector/material specific helpers: `getItensPorSetor(setor)` filters the order list (or queries a dedicated index) for the requested `setorAtual`, `consultarMateriais(itemId)` returns the `materiaisNecessarios` array/derived data, and `getDashboardSetor(setor?)` summarizes statuses/times from the live orders as described in `DashboardTV` (consider caching the summary document if needed).
- [ ] Implement mutations (`entradaSetor`, `saidaSetor`, `atualizarProgresso`, `rejeitarItem`, `pausarItem`, `retomarItem`) that update the nested `itens` / `status` fields and optionally persist `MovimentacaoSetor` records, always calling `producaoFirestoreService.update` so audit logs & `insertedBy` metadata stay consistent.
- [ ] Sync the newly implemented methods with the hooks/pages: ensure `useEntradaSetor`/`useSaidaSetor`/`useAtualizarProgresso` etc call the domain service methods, validate the returned data shape for toasts/UI, and adjust `SetorProducao`/`ConsultMaterial` types if the Firestore payload differs.
- [ ] Review `firestore.rules`/`firestore.indexes.json` to add any needed indexes for queries filtered by `setorAtual`, `prioridade`, or `materiaisDisponiveis`, and confirm the security rules allow the new mutations while still enforcing `belongsToTenant` and the permission matrix.
- [ ] Validate the entire flow by exercising `ControleProducao`/`DashboardTV`/`ApontamentoOP` against the new domain service (using the mock data layer if necessary), ensuring the React Query hooks refresh as expected and the audit+soft-delete behavior works.

## Testing and validation
- Manual QA: use the mock handler or Firestore seed to exercise `ControleProducao` mutations (entrada/saÇðda/progresso) and watch for toast success, query invalidations, and updated statuses in the UI.
- TypeScript build: run `npm run build` (or equivalent) to catch missing imports/types now that the domain service has a richer API surface.
- Firestore rules simulation: use the emulator (if available) or a lint tool to confirm the new writes still satisfy `belongsToTenant`, `hasPermission`, and that added indexes align with the queries.

## Risks and edge cases
- Migrating existing `ordens_producao` docs to include the new nested fields (materiais, movimentaÇõÇæes, progresso) may require scripts or backfilling if current production data lacks them.
- Sector transitions rely on a fixed sequence (`Corte` ƒÅ' ... ƒÅ' `Expedicao`); if the real process deviates, the `saidaSetor` logic must be configurable to avoid locking items.
- Persisting `MovimentacaoSetor` documents while keeping them in sync with nested `itens` arrays can double-write the same data, so the plan must clarify whether to use subcollections or embedded arrays to avoid inconsistencies.
- Firestore indexes might be missing for filtering by `setorAtual`/`prioridade`, causing query failures; plan to add them before roll-out.

## Open questions
- Where should `MovimentacaoSetor` records live? A subcollection under each order, a dedicated collection, or embedded in the order document?
- Should `getDashboardSetor` compute stats on-demand from live order data, or persist aggregates in a supporting document/collection for faster TV rendering?
- Do we need to expose `consultaMateriais` results from a separate inventory collection instead of relying on data stored inside each order item?


[2026-02-07T02:58:57] tokens used: 366.745
